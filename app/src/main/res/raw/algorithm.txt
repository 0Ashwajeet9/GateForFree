1. Introduction to Algorithms
0IAPZzGSbME
1.1 Priori Analysis and Posteriori Testing
-JTq1BFBwmo
1.2 Characteristics of Algorithm
FbYzBWdhMb0
1.3 How Write and Analyze Algorithm
xGYsEqe9Vl0
1.4 Frequency Count Method
1U3Uwct45IY
1.5.1 Time Complexity #1
9TlHvipP5yA
1.5.2 Time Complexity Example #2
9SgLBjXqwd4
1.5.3 Time Complexity of While and if #3
p1EnSvS3urU
1.6 Classes of functions
w7t4_JUUTeg
1.7 Compare Class of Functions
5v-tKX2uRAk
1.8.1 Asymptotic Notations Big Oh - Omega - Theta #1
A03oI0znAoc
1.8.2 Asymptotic Notations - Big Oh - Omega - Theta #2
Nd0XDY-jVHs
1.9 Properties of Asymptotic Notations
NI4OKSvGAgM
1.10.1 Comparison of Functions #1
mwN18xfwNhk
1.10.2 Comparison of Functions #2
WlBBTSL0ZRc
1.11 Best Worst and Average Case Analysis
lj3E24nnPjI
1.12 Disjoint Sets Data Structure - Weighted Union and Collapsing Find
wU6udHRIkcc
2 Divide And Conquer
2Rr2tW9zvRg
2.1.1 Recurrence Relation (T(n)= T(n-1) + 1) #1
4V30R3I1vLI
2.1.2 Recurrence Relation (T(n)= T(n-1) + n) #2
IawM82BQ4II
2.1.3 Recurrence Relation (T(n)= T(n-1) + log n) #3
MhT7XmxhaCE
2.1.4 Recurrence Relation T(n)=2 T(n-1)+1  #4
JvcqtZk2mng
2.2 Masters Theorem Decreasing Function
CyknhZbfMqc
2.3.1 Recurrence Relation Dividing Function T(n)=T(n/2)+1 #1
8gt0D0IqU5w
2.3.2 Recurrence Relation Dividing [ T(n)=T(n/2)+ n].   #2
XcZw01FuH18
2.3.3 Recurrence Relation [ T(n)= 2T(n/2) +n]  #3
1K9ebQJosvo
2.4.1 Masters Theorem in Algorithms for Dividing Function #1
OynWkEj0S-s
2.4.2 Examples for Master Theorem #2
kGcO-nAm9Vc
2.5 Root function (Recurrence Relation)
9rVuyjxzwgM
2.6.1 Binary Search Iterative Method
C2apEw9pgtw
2.6.2 Binary Search Recursive Method
uEUXGcc2VXM
2.6.3 Heap - Heap Sort - Heapify - Priority Queues
HqPJF2L5h9U
2.7.1  Two Way MergeSort - Iterative method
6pV2IF0fgKY
2.7.2.  Merge Sort Algorithm
mB5HXBb_HY8
2.7.3 MergeSort in-depth Analysis
ak-pz7tS5DE
2.8.1  QuickSort Algorithm
7h1s2SojIRw
2.8.2 QuickSort Analysis
-qOVVRIZzao
2.9 Strassens Matrix Multiplication
0oJyNmEbS4w
3. Greedy Method -  Introduction
ARvQcqJ_-NY
3.1 Knapsack Problem - Greedy Method
oTTzNMHM05I
3.2 Job Sequencing with Deadlines - Greedy Method
zPtI8q9gvX8
3.3 Optimal Merge Pattern - Greedy Method
HHIc5JZyenI
3.4 Huffman Coding - Greedy Method
co4_ahEDCho
3.5 Prims and Kruskals Algorithms - Greedy Method
4ZlRH0eK-qQ
3.6 Dijkstra Algorithm - Single Source Shortest Path - Greedy Method
XB4MIexjvY0
4 Principle  of Optimality  - Dynamic Programming introduction
5dRGRueKU3M
4.1 MultiStage Graph - Dynamic Programming
9iE9Mj4m8jk
4.1.1 MultiStage Graph (Program) - Dynamic Programming
FcScLYJI42E
4.2 All Pairs Shortest Path (Floyd-Warshall) - Dynamic Programming
oNI0rf2P9gE
4.3 Matrix Chain Multiplication - Dynamic Programming
prx1psByp7U
[New] Matrix Chain Multiplication using Dynamic Programming Formula
_WncuhSJZyA
4.3.1 Matrix Chain Multiplication (Program) - Dynamic Programming
eKkXU3uu2zk
4.4 Bellman Ford Algorithm - Single Source Shortest Path - Dynamic Programming
FtN3BYH2Zes
4.5 0/1 Knapsack - Two Methods - Dynamic Programming
nLmhmB6NzcM
4.5.1 0/1 Knapsack Problem (Program) - Dynamic Programming
zRza99HPvkQ
4.6 Optimal Binary Search Tree (Successful Search Only) - Dynamic Programming
vLS-zRCHo-Y
4.6.2 [New] Optimal Binary Search Tree Successful and Unsuccessful Probability - Dynamic Programming
wAy6nDMPYAE
4.7 [New] Traveling Salesman Problem - Dynamic Programming using Formula
Q4zHb-Swzro
4.8 Reliability Design - Dynamic Programming
uJOmqBwENB8
4.9 Longest Common Subsequence (LCS)  - Recursion and Dynamic Programming
sSno9rV8Rhg
5.1 Graph Traversals - BFS & DFS -Breadth First Search and Depth First Search
pcKY4hjDrxk
5.2 Articulation Point and Biconnected Components
jFZsDDB0-vo
6 Introduction to Backtracking - Brute Force Approach
DKCbsiDBN6c
6.1 N Queens Problem using Backtracking
xFv_Hl4B83A
6.2 Sum Of Subsets Problem - Backtracking
kyLxTdsT8ws
6.3 Graph Coloring Problem - Backtracking
052VkKhIaQ4
6.4 Hamiltonian Cycle - Backtracking
dQr4wZCiJJ4
7 Branch and Bound Introduction
3RBNPc0_Q6g
7.1 Job Sequencing with Deadline - Branch and Bound
M7Fl_z7_J2k
7.2 0/1 Knapsack using Branch and Bound
yV1d-b_NeK8
7.3 Traveling Salesman Problem - Branch and Bound
1FEP_sNb62k
8. NP-Hard and NP-Complete Problems
e2cF8a5aAhE
8.1 NP-Hard Graph Problem - Clique Decision Problem
qZs767KQcvE
9.1 Knuth-Morris-Pratt KMP String Matching Algorithm
V5-7GzOfADQ
9.2 Rabin-Karp String Matching Algorithm
qQ8vS2btsxI
10.1 AVL Tree - Insertion and Rotations
jDM6_TnYIqE
10.2  B Trees and B+ Trees. How they are useful in Databases
aZjYr87r1b8
Asymptotic Notations - Simplified
ddsP7NecEBk
Hashing Technique - Simplified
mFY0J5W8Udk
Shortest Path Algorithms (Dijkstra and Bellman-Ford)  - Simplified
2raV0H9KqY8
BFS DFS - Simplified
kyUpc_5705s
Tower of Hanoi Problem - Made Easy
q6RicK1FCUs
Row-Major and Column-Major Mapping
MJZd6uPi88E
Merge Sort Algorithm - Hindi
zXhWPrMLXGo
